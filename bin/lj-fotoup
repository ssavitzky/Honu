#!/usr/bin/perl
#
# Tool to upload pictures to a FotoBilder server.
#
# Brad Fitzpatrick <brad@danga.com>
#

use strict;
use LWP::UserAgent;
use Digest::MD5 qw(md5_hex);
use Getopt::Long;
use URI::Escape;
use XML::Simple;
use File::Find;
use File::Basename;

my $CONFFILE = "$ENV{'HOME'}/.fotoup.conf";

my ($opt_help, 
    $opt_public, $opt_private, 
    $opt_backup, 
    $opt_recursive,
    @opt_under,
    @opt_gallery, $opt_date);
exit 1 unless GetOptions('help' => \$opt_help,
                         'public|u' => \$opt_public,
                         'private|v' => \$opt_private,
                         'backup' => \$opt_backup,
                         'recursive' => \$opt_recursive,
                         'under=s' => \@opt_under,
                         'gallery=s' => \@opt_gallery,
                         'date=s' => \$opt_date,
                         );

if ($opt_help || (! $opt_backup && @ARGV == 0)) {
    print STDERR "Usage: fotoup.pl [opts] <files_or_dirs>+\n\n";
    print STDERR "Options:\n";
    print STDERR "    --gallery=\"Gallery Name\"  (more than 1 okay)\n";
    print STDERR "    --under=\"Gallery Name\"    (more than 1 okay)\n";
    print STDERR "    --recursive               upload directories of pictures\n";
    print STDERR "    --date=\"datestring\"       Optional date of new gallery (format: yyyy[-mm[-dd[[ hh:mm[:ss]]]]])\n";
    print STDERR "    --public                  make security public\n";
    print STDERR "    --private                 make security private\n";
    print STDERR "    --backup                  make local backup of your entire account\n";
    exit 1;
}

if ($opt_private && $opt_public) {
    die "Private & public are mutually exclusive.\n";
}

unless (-s $CONFFILE) {
    open (C, ">>$CONFFILE"); close C; chmod 0700, $CONFFILE;
    print "\nNo ~/.fotoup.conf config file found.\nFormat:\n\n";
    print "server: pp.com\n";
    print "username: bob\n";
    print "password: my password\n";
    print "# optional\n";
    print "# defaultsec values: 0=private, 253=reg users only, 254=friends, 255=public\n";
    print "defaultsec: 0\n";
    exit 1;
}

my %conf;
open (C, $CONFFILE);
while (<C>) {
    next if /^\#/;
    next unless /\S/;
    chomp;
    next unless /^(\w+)\s*:\s*(.+)/;
    $conf{$1} = $2;
}
close C;

my $is_dirs = 0;
my $is_files = 0;
my $is_topfiles = 0;
foreach (@ARGV) {
    die "Unknown file or directory: $_\n" unless -e $_;
    $is_dirs = 1 if -d _;    
    if (-f _) {
        $is_files = 1;        
        unless (m!/!) { # TODO: use File::Spec for portability
            $is_topfiles = 1;
        }
    }
}

if ($is_dirs && ! $opt_recursive) {
    die "To upload directories, use --recursive\n";
}

if ($opt_recursive && @opt_gallery) {
    die "Can't use specify --gallery names when using --recursive\n";
}

if ($is_topfiles && $opt_recursive && ! @opt_under) {
    die "When uploading a mix of directories and files recursively, you must specify at least one --under=\"\" gallery so the server will know where to put your top-level pictures.\n";
}

# expand directories
my @files;
foreach my $file (@ARGV) {
    if (-f $file) {
        push @files, $file;
        next;
    }
    if (-d $file) {
        find({
            'wanted' => sub {
                return if /\.(xvpics|thumbnails|thumbs)/;  # TODO: add more common thumbnail patterns?
                return unless -f $_;
                push @files, $_;
            },
            'no_chdir' => 1,
        }, $file);
    }
}

@files = sort @files;

my $ua = LWP::UserAgent->new;
$ua->agent("FotoBilder_Uploader/0.1");
my $chal = "";

sub error_as_str
{
    my $res = shift;
    return "" unless $res;
    return $res->code . " " . $res->message . "\n\n" . $res->content;
}

sub get_challenge
{
    my $req = HTTP::Request->new(PUT => "http://$conf{'server'}/interface/upload");
    $req->push_header("X-FB-Username" => $conf{'username'});
    $req->push_header("X-FB-MakeChallenge" => 1);
    
    my $res = $ua->request($req);
    return scalar $res->header("X-FB-NewChallenge")
	if $res->is_success;
	
    die "Error getting challenge from server: " . error_as_str($res);
}

sub make_auth
{
    my $chal = shift;
    return "crp:$chal:" . md5_hex($chal . md5_hex($conf{'password'}));
}

while (@files)
{
    my $file = shift @files;
    unless (-e $file) {
        print STDERR "File doesn't exist: $file\n";
        next;
    }

    print "Uploading: $file\n";

    my @gals;
    if ($opt_recursive) {
        my @paths = @opt_under;
        my $dir = $file;
        $dir =~ s!^\.{0,2}\/!!;
        push @paths, split(m!/+!, $dir);
        pop @paths;  # pop the filename
        push @gals, join("\0", @paths);
    } else {
        @gals = @opt_gallery;
    }

    unless ($chal) {
        print "Getting challenge...\n";
	$chal = get_challenge();
    }
    unless ($chal) {
        die "No challenge string available.\n";
    }

    my $basefile = basename($file);
    my $img;
    open (F, $file);
    binmode(F);
    { local $/ = undef;
      $img = <F>; }
    close F;
    
    my $length = length($img);
    my $md5 = Digest::MD5::md5_hex($img);
    my $magic = substr($img, 0, 10);
    $magic =~ s/(.)/lc sprintf("%02x",ord($1))/egs;
    
    # Create a request
    my $req = HTTP::Request->new(PUT => "http://$conf{'server'}/interface/upload");
    $req->push_header("Content-Length" => $length);
    $req->push_header("X-FB-Meta-Filename" => uri_escape($basefile));
    $req->push_header("X-FB-Magic" => $magic);
    $req->push_header("X-FB-MD5" => $md5);
    $req->push_header("X-FB-Username" => $conf{'username'});
    my $auth = make_auth($chal);
    $req->push_header("X-FB-Auth" => $auth);
    $req->push_header("X-FB-MakeChallenge" => 1) if @ARGV;
    foreach (@gals) {
        my $sec = $conf{'defaultsec'}+0;
        if ($opt_private) { $sec = 0; }
        elsif ($opt_public) { $sec = 255; }
        if (/\0/) {
            print "Adding to gallery: [", join(" // ", split(/\0/, $_)), "]\n";
        } else {
            print "Adding to gallery: $_\n";
        }
        my $val = "name=" . uri_escape($_) . "&" .
            "galdate=" . uri_escape($opt_date) . "&" .
            "picsec=$sec&galsec=$sec";
        $req->push_header("X-FB-Gallery" => $val);
    }
    $req->content($img);
    
    my $res = $ua->request($req);
    $chal = $res->header("X-FB-NewChallenge");
    if ($res->is_success) {
        print $res->content, "\n";
    } else {
        my $error = ($res->content() || error_as_str($res));
        print $error, "\n";
    }
}

if ($opt_backup)
{
    my $backdir = $conf{'backupdir'};
    die "Can't backup:  no 'backupdir' specified in ~/.fotoup.conf\n"
	unless $backdir;

    $backdir =~ s!^\~/!$ENV{'HOME'}/!;
    die "Can't make backup directory: $backdir\n"
	unless (-d $backdir || mkdir $backdir, 0700);

    my $pooldir = "$backdir/pool";
    die "Can't make pool directory: $pooldir\n"
	unless (-d $pooldir || mkdir $pooldir, 0700);
   
    # fetch the export XML file
    {
	print "Fetching export.xml from server...\n";
	my $req = HTTP::Request->new('POST', "http://$conf{'server'}/manage/export");
	my $auth = make_auth(get_challenge());
	$auth .= ":$conf{'username'}";
	$req->push_header("Cookie" => "fbsession=" . $auth);
	my $res = $ua->request($req);
	die "Couldn't fetch export XML file from server\n" 
	    unless $res->is_success;
	open (E, ">$backdir/export.xml") or die "Can't open export.xml\n";
	print E $res->content;
	close E;
    }
    
    my %altfile;  # file -> hashref
    my %altmd5;   # md5 -> hashref
    open (A, "$backdir/altfiles.dat");
    while (<A>) {
	chomp;
	my ($file, $size, $mtime, $md5) = split /\t/;
	$altmd5{$md5} = $altfile{$file} = {
	    'file' => $file,
	    'size' => $size,
	    'mtime' => $mtime,
	    'md5' => $md5,
	    'valid' => 0,  # will become valid later, or deleted.
	};
    }
    close A;
    open (A, ">>$backdir/altfiles.dat") or die "Can't append to altfiles.dat\n";
    select(A); $| = 1; select(STDOUT);
    
    # discover new pictures
    my @index = split(/\s*\,\s*/, $conf{'backupindex'});
    foreach (@index) {
	s!^\~/!$ENV{'HOME'}/!;
	my $id = $_;
	print "Discovering existing pictures in: $id\n";
	my @new;
	my $same;
	find({
	    'wanted' => sub { 
		return unless -f $_;
		my $size = -s _;
		my $mtime = (stat(_))[9];
		if ($altfile{$_} && 
		    $altfile{$_}->{'mtime'} == $mtime &&
		    $altfile{$_}->{'size'} == $size) 
		{
		    # mark that it's still alive.
		    $altfile{$_}->{'valid'} = 1;
		    $same++;
		    return;
		}
		push @new, [ $_, $size, $mtime ];
	    },
	    'no_chdir' => 1,
	},  $id);

	my $new = @new;
	print "  $same files already known.\n";
	if ($new) {
	    print "  $new files to learn...\n";
	    print "    0/$new (0.0%)\n";
	}
	my $done;
	foreach my $n (@new)
	{
	    my ($file, $size, $mtime) = @$n;

	    my $ctx = Digest::MD5->new;
	    open (F, $file) or die "Can't open file $file";
	    $ctx->addfile(\*F);
	    close F;
	    my $md5 = $ctx->hexdigest;

	    print A "$file\t$size\t$mtime\t$md5\n";
	    if (++$done % 10 == 0) {
		printf "    $done/$new (%.01f%)\n", (100*$done/$new);
	    }

	    $altmd5{$md5} = $altfile{$file} = {
		'file' => $file,
		'size' => $size,
		'mtime' => $mtime,
		'md5' => $md5,
		'valid' => 1,
	    };
	}

    }
    close A;

    # forget about files that have disappeared
    {
	my @remove;
	while (my ($file, $p) = each %altfile) {
	    push @remove, $p unless $p->{'valid'};
	}
	foreach my $p (@remove) {
	    delete $altmd5{$p->{'md5'}};
	    delete $altfile{$p->{'file'}};
	}
    }

    my $ex = XMLin("$backdir/export.xml",
		    keyattr => [ ],
		    );

    my $total = scalar @{$ex->{'pics'}->{'pic'}};
    print "Total pictures: $total\n";
    my $good = 0;
    my @backup;

    # check to see what we already have
    foreach my $p (@{$ex->{'pics'}->{'pic'}}) {
	my $md5 = $p->{'md5'};
	die "Bogus md5: $md5" unless $md5 =~ /^(..)(..).{28,28}$/;
	my ($pa, $pb) = ($1, $2);
	
	my $padir = "$pooldir/$pa";
	die "Can't make pooldir: $padir"
	    unless -d $padir || mkdir $padir, 0700;
	my $pbdir = "$pooldir/$pa/$pb";
	die "Can't make pooldir: $pbdir"
	    unless -d $pbdir || mkdir $pbdir, 0700;

	my $ext;
	if ($p->{'format'} eq "image/jpeg") { $ext = ".jpg"; }
	elsif ($p->{'format'} eq "image/gif") { $ext = ".gif"; }
	elsif ($p->{'format'} eq "image/png") { $ext = ".png"; }

	# location in pool
	my $dfile = "$pbdir/$md5$ext";
	
	# save for later:
	$p->{'-dfile'} = $dfile;

	if (-l $dfile) {
	    my $dest = readlink $dfile;
	    my $a = $altfile{$dest};
	    if ($a && $a->{'md5'} eq $md5) {
		$good++;
		next;
	    }
	} else {
	    # is it in the pool as a regular file?
	    if (-f $dfile && -s _ == $p->{'bytes'}) {
		# but maybe there's since become a copy elsewhere
		# so we could kill the pool copy and save some disk space.
		my $a = $altmd5{$p->{'md5'}};
		if ($a) {
		    unlink $dfile;
		    if (symlink $a->{'file'}, $dfile) {
			print "Deleted pool copy, replaced with link to $a->{'file'}\n";
			$good++;
			next;
		    }		
		} else {
		    $good++;
		    next;
		}
	    }
	}

	if ($altmd5{$p->{'md5'}}) {
	    unlink $dfile;
	    my $file = $altmd5{$p->{'md5'}}->{'file'};
	    if (symlink $file, $dfile) {
		$good++;
		next;
	    }
	}
	
	push @backup, $p;
    }

    print "Already backed up: $good\n";

    my $files_total = @backup;
    my $files_done = 0;
    print "Pictures to backup: $files_total\n";

    my $bytes_total = 0;
    my $bytes_done = 0;
    foreach my $p (@backup) { $bytes_total += $p->{'bytes'};   }
    print "Bytes to fetch over network: $bytes_total\n";

    $| = 1;
    foreach my $p (@backup) {
	$files_done++;
	print "  Fetching image $files_done/$files_total ... ";

	my $tempfile = "$pooldir/.picdownload.$p->{'picid'}";
	open (S, ">$tempfile") or die "Can't make download file: $tempfile\n";
	binmode(S);
	my $callback = sub {
	    my ($data, $response, $protocol) = @_;
	    print S $data;
	};

	my $req = HTTP::Request->new('GET', $p->{'url'});
	
	# for non-public pics, we need to authenticate
	if ($p->{'secid'} != 255) {
	    my $auth = make_auth(get_challenge());
	    $auth .= ":$conf{'username'}";
	    $req->push_header("Cookie" => "fbsession=" . $auth);
	}

	my $res = $ua->request($req, $callback, 4096);
	unless ($res->is_success) {
	    my $error = ($res->content() || error_as_str($res));
	    print "Error: \#$p->{'picid'}: $error\n";
	    next;
	}
	close S;

	# be paranoid and verify file's md5 (did download work?)
	open (S, $tempfile);
	my $ctx = Digest::MD5->new;
	$ctx->addfile(\*S);
	close F;
	my $md5 = $ctx->hexdigest;
	close S;
	die "MD5 of downloaded file doesn't match.\n"
	    unless $md5 eq $p->{'md5'};
	
	# move file to its permanent home
	unlink $p->{'-dfile'};
	rename $tempfile, $p->{'-dfile'};

	$bytes_done += $p->{'bytes'};
	printf " %0.01f%%\n", ($bytes_done/$bytes_total*100);

    }

}
